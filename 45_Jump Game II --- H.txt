Given an array of non-negative integers, you are initially positioned at the first index of the array.
Each element in the array represents your maximum jump length at that position.
Your goal is to reach the last index in the minimum number of jumps.

Input: [2,3,1,1,4]                          Output: 2
Input: [7,0,9,6,9,6,1,7,9,0,1,2,9,0,3]      Output: 2

-------------------------------------------------------------------------------------------------------------

class Solution {
public:
    int jump(vector<int>& nums) {
        
        // Corner Case
        if (nums.size() <= 1) return 0;
        
        /*
         * Efficient Approach -- Using furthest moved so far algorithm
         */
        int furthest_so_far = 0, min_steps_moved = 1, last_index = nums.size() - 1, current_end_index = 0;
        
        for (int i = 0; i <= furthest_so_far; ++i) {
            furthest_so_far = std::max(furthest_so_far, (i + nums[i]));

            if (furthest_so_far >= last_index) return min_steps_moved;
            
            if (i == current_end_index) {
                current_end_index = furthest_so_far;
                ++min_steps_moved;
            }
        }
        
        return INT_MAX; // Not able to reach to last index

        /*
         * Similar Solution just if input will always reach to last index
         */
        /*int furthest_so_far = 0, min_steps_moved = 1, last_index = nums.size() - 1, current_end_index = 0;
        
        for (int i = 0; i <= furthest_so_far && furthest_so_far < last_index; ++i) {
            
            furthest_so_far = std::max(furthest_so_far, (i + nums[i]));
            
            if (i == current_end_index && furthest_so_far < last_index) {
                current_end_index = furthest_so_far;
                ++min_steps_moved;
            }
            
        }
        
        return min_steps_moved;*/
    }
};

-------------------------------------------------------------------------------------------------------------