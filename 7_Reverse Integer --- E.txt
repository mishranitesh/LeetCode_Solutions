Given a 32-bit signed integer, reverse digits of an integer.
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.
Input: 123
Output: 321
Input: -123
Output: -321
Input: 120
Output: 21
Input: 1534236469
Output: 0

-------------------------------------------------------------------------------------------------------------

class Solution {
public:
    int reverse(int x) {
        
        int x_abs = abs(x), reverse_num = 0;
        std::size_t num_check = 0;
        
        /*
         * Brute Force Approach -- Using std::string to reverse digit
         */
        /*std::string str_num = std::to_string(abs(x));
        std::reverse(str_num.begin(), str_num.end());
        if (x < 0) {
            str_num.insert(0, 1, '-');
        }
        try {
            reverse_num = std::stoi(str_num);
        } catch(std::out_of_range) {
            return 0;
        }*/
        
        /*
         * Efficient Approach -- Using arithmetic operation
         */
        while (x_abs) {
            num_check = (num_check * 10) + (x_abs % 10);
            
            // Check if 8 byte size_t value exceeds limit of 4 byte int limit
            if (num_check > INT_MAX) {
                return 0;
            }
            
            reverse_num = num_check;
            x_abs /= 10;
        }
        
        return (x < 0) ? (reverse_num * -1) : reverse_num;
    }
};
-------------------------------------------------------------------------------------------------------------